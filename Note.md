# Built application files

## 学习笔记《Kotlin实战》

### 第一、二章

* Kotlin和Java一样都是一种静态类型语言，所有表达式的类型在编译期已经确定。动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明,通常变量的类型是被赋值的那个值的类型。例如:Python、Ruby、Groovy等。
* Kotlin支持类型推导。
* Kotlin支持面向对象和面向函数两种风格。
* 数组就是类，Kotlin没有声明数组类型的特殊语法。
* if是表达式，不是语句。表达式和语句的区别是：表达式有值，并且能作为另一个表达式的一部分使用。语句总是包围着它的代码块中的顶层元素，并且没有自己的值。Java
  中所有的控制结构都是语句，而Kotlin中除了循环以外，大多数控制结构都是表达式。
* val——不可变引用，初始化后不能在被赋值，对应Java的final变量。
* var——可变引用，变量的值可以被改变。
* 尽管val引用自身不可变，但是它指向的对象可能是改变的。 例如：
  """
  val languages = arrayListOf("java") // 声明不可变引用 languages.add("Kotlin")             // 改变引用指向的对象
  """
* 只读属性只有一个getter，可写属性既有getter又有setter。
* enum 是一个软关键字，只有当它出现在class前面才有特殊的意义（即枚举的意思），其它地方可以把它当做普通的名称使用。Kotlin中的枚举类可以声明属性和方法。
* when 可以是一个有返回值的表达式。
* Java 的Switch要求必须使用常量作为分支条件。Kotlin的when允许使用任何对象。
* 如果没有给when表达式提供参数，分支条件就是任意的布尔类型表达式。
* is关键字是用来判断一个变量是否为某种类型（相当于Java的instanceof），如果检查过一个变量是某种类型，后面就不需要再转换它，可以把它当做你检查过的类型使用。Java的instanceof，即使检查是某种类型，也需要显示转换。
* 使用as可以显示特定类型的转换。
* .. 语法始终创建的是包含创结束值（..右边的值）的区间。如果想是结束区间半闭合区间，使用until函数。
* Kotlin中的throw结构是一个表达式，能作为另一个表达式的一部分使用。
* Kotlin中try关键字和if一样，引入了一个表达式，可以把它的值赋给一个变量。

### 第三章

* 可以在函数声明的时候指定参数默认值，避免创建多个重载的函数。
* 把函数放在代码文件的顶层，不用从属于任何的类。这样可以比用写静态工具类方法。
* 扩展函数可以直接访问被扩展的类的其他方法和属性，且扩展函数不能打破它的封装性，不能访问私有的或者受保护的成员。
* 实质上，扩展函数是静态函数（在Java中会被编译成静态函数），它把调用对象作为它的第一个参数。调用扩展函数，不会创建适配的对象或者任何运行的额外消耗。它的本质还是静态函数的高效语法糖。可以使用更具体的类型作为接受者类型，而不是一个类。
* 扩展函数不能被子类重写。它不是类的一部分，而是声明在类之外的。
* 扩展函数不存在重写，因为Kotlin会把他们当做静态函数对待。
* 如果父类和子类都分别定义一个同名的扩展函数，那么具体调用那个由该变量的静态类型所决定，而不是这个变量的运行时类型
* to函数是一个扩展函数，可以创建一对任何元素，它是泛型接收者的扩展。
* Kotlin中可以使用扩展函数toRegex将字符串转换为正则表达式。
* 三重引号字符串可以避免转义字符，
* 局部函数可以访问所在函数中的所有参数和变量。使用局部函数可以保证代码的整洁同时，避免重复。

### 第四章

* Kotlin的接口方法在声明时可以有默认实现。Java8 需要也可以，但需要在实现上标注default关键字。
* Kotlin中类和方法默认都是public、final的，如果想允许创建一个子类，需要使用open修饰符来标识这个类。此外，需要给每一个可以被重写的属性、方法添加open修饰符。
* 抽象类默认是open的，抽象方法在抽象类中不能有默认实现，且子类必须实现，非抽象方法默认是final的，声明后必须有默认实现。
* Kotlin没有default关键字（该关键字在Java中对应的是包可见性），但是提供了internal——只在模块内部可见，一个模块就是一组一起编译的Kotlin文件。
* internal是Kotlin独有的，在编译成字节码时对应的是Java的public，由于可见性范围和Java区别，因此最好不要使用internal，否则会导致Java和Kotlin互相调用异常。
* Kotlin中protected成员只能在类和它的子类中可见，类的扩展函数不能访问它的private和protected成员。
* Kotlin的嵌套类不能访问外部类的实例。
* 类A（作为嵌套类）在类B中声明，如果类A不想存储外部类B的引用，在Java中声明类A的方式是static class A，在Kotlin中声明类A的方式是class
  A。即Kotlin中没有显示修饰符的嵌套类与Java中的static嵌套类是一样的。
* 类A（作为嵌套类）在类B中声明，如果类A存储外部类B的引用，在Java中声明类A的方式是class A，在Kotlin中声明类A的方式是inner class A。
* When结构来执行表达式的时候，Kotlin编译器会强制检查默认选项。
* 在When表达式中处理所有的sealed类的子类，就不需要再提供默认分支。sealed修饰符隐含的这个类是一个open。
* sealed修饰的类叫做密闭类，相当于Java的枚举类Enum。
* init关键字用来引入一个初始化语句块，在类被创建时执行的代码块。
* 如果所有的构造方法参数都有默认值，编译器会生成一个额外的不带参数的构造方法来使用所有的默认值。
* 不要声明多个从构造方法用来重载和提供参数的默认值，取而代之的是应该直接标明默认值。
* Kotlin中的== 相当于Java的equals（比较的是对象的值），Kotlin中的 === 相当于Java的==（比较的是对象的引用）
* object关键字定义一个类并同时创建一个实例（对象），对象的声明是定义一个单例的一种方式。
* object声明类不能有构造方法（包括主构造、从构造）
* Kotlin中的对象声明被编译成了通过静态字段来持有它的单一实例的类，这个字段名称始终是INSTANCE，因此，要从Java代码中使用Kotlin对象，可以通过访问静态的INSTANCE字段。
* Kotlin中的类不能拥有静态成员；Java的static关键字不是Kotlin语言的一部分。Kotlin依赖的是包级别函数和对象声明。
* 在没有类实例的情况下调用但是需要访问类内部的函数，可以将其写成那个类的对象声明的成员。
* 伴生对象可以访问类中所有的private成员，包括private 构造方法。
* 使用companion object （伴生对象）可以直接通过容器类名来访问这个对象的方法和属性，写法上非常像Java的静态方法调用。也可以实现单例（相当于Java的静态内部类的写法）
* Kotlin可以访问在Java类中声明的静态方法和字段，使用与Java相同的语法。
* object 关键字还可以声明匿名对象。匿名对象替代了Java中匿名内部类的写法。

### 第五章

* Lambda 的本质是可以传递给其它函数一小段代码.
* 当lambda是函数唯一的实参时，可以去掉调用者代码中空括号对。如果实参可以导出来，也可不用显示指定。
* 在嵌套lambda中，最好显示的声明每个lambda的实参.
* Kotlin允许在lambda内部访问非final变量甚至修改它，Java不行。
* filter 函数可以从集合中过滤掉一些元素，但不会真正的改变这个集合
* map函数可以对集合中的每一个元素应用给定的函数并把结果收集到一个新的集合中。
* filter 和 map都会返回一个列表。
* Kotlin 的Sequence接口表示一个可以逐个列举元素的元素序列，内部提供了一个方法，iterator，用来从序列中获取值。
* 序列中的元素求值是惰性的，因此可使用序列更加高效的对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的中间结果。
* 在序列操作中，map、filter都是中间操作，返回是另一个序列，toSet是一次末端操作，返回的是一个结果。没有末端操作的调用，中间操作是不会被调用的。
* 即序列是允许你合并一个集合上的多次操作，而不需要创建新的集合来
* lambda内部没有匿名对象那样的this，没有办法引用到lambda转换成匿名类实例。
* lambda中的this引用指向的是包围它的类
* with的返回值是执行lambda的结果，该结果是lambda中最后一个表达式

### 第六章

* 当Kotlin函数使用Any时，它会被编译成Java字节码中的Object。
* Any是非空的，如果要使用成空的，需要使用Any？。
* 在Java中Object是所有引用类型的超类，基本数据类型并不是类层级结构的一部分。
* 在Kotlin中Any是所有类型的超类。把基本数据类型的值给Any类型的变量时会自动装箱。
* 每一种基本数据类型都定义有转换函数，例如toLong()，且这些函数支持双向转换，即可以把小类型转换成大类型，例如Int转long，也可以将大类型转小类型，例如long转Int。
* Kotlin要求转换必须是显式的，尤其是在比较装箱值的时候。
* 在实现Java类或者接口的方法时一定要搞清楚它的可空性。
* 对于公有的Kotlin函数，编译器会生成对每个非空类型的参数的检查，使用不正当参数的调用尝试都会立即被报告为异常。这种检查在函数调用的时候就执行了，而不是等到这些参数被使用的时候。
* Kotlin中所有泛型类和泛型函数的类型参数默认都是可空的。
* Java中，this永远是非空的，因为它引用的是当前你所在这个类的实例。而在Kotlin中，这并不永远成立，在可空类型的扩展函数中，this可以为null。
* 可空的和非空的对象在运行时没有什么区别，可空类型并不是非空类型的包装。所有的检查都发生在编译期。
*
Java有一些帮助解决空指针的工具，例如注解：@Nullable、@NotNull。在Java8中引入的Optional类型这样的特殊包装类型来表示这个值可能没有被定义，使用这种方式会使代码冗长影响运行时的性能。还有就是一些三方工具的辅助检查。
* 如果一个变量可以为null，对变量的方法的调用就是不安全的。
* Kotlin中的Unit类型完成了Java中的Void一样的功能。
* Kotlin中的Unit和Java中的Void的区别：Unit是一个完备的类型，可以作为类型参数，而Void却不行。
* Kotlin完全支持类型参数的可空性。例如ArrayList<Int?>()
* Kotlin将访问集合数据的接口与修改集合数据的接口分开了。其中Collection接口是只读且不可以修改，MutableCollection接口继承自Collection接口，可以修改集合中的数据。
* 每一种Java集合接口在Kotlin中都有两种表示，一种是只读的，另一种可变的。在Kotlin中继承或者实现Java接口时，需要仔细考虑参数的可空性和可变性。
* 不正常终止的函数使用Nothing类型作为返回类型。
* Kotlin的Array类就像普通的泛型类，但他会被编译成Java数组。

### 第七章

* 用于重载运算符的所有函数都需要用operator关键字修饰。
* Java没有定义任何用于标记运算符函数的语法。
* 在Kotlin 中，compareTo的返回类型必须为Int。p1 < p2表达式等价于 p1.compareTo(p2) < 0 .
* 在Kotlin中，下标运算符是一个约定。使用下标运算符读取元素会被转换成get运算符方法的调用（需要使用operator标记），并且写入元素将调用set。
* rangeTo 函数返回一个区间，其运算符的优先级低于算数运算符。
* 解构声明可以展开单个对象用来初始化多个变量，这可以方便的用来从函数返回多个值
* lazy函数是线程安全的。
* 委托属性可以用来重用逻辑，这些逻辑控制如何存储、初始化、访问和修改属性值，这是用来构建框架的一个强大的工具。
* 委托属性可以使用任意map来作为属性委托。来灵活处理具有可变属性集的对象。
* Delegates.observable函数可以用来添加属性更改的观察者。


### 第八章

* 高阶函数就是以另一个函数作为参数或者返回值的函数，在Kotlin中，函数可以用lambda或者函数的引用来表示。
* 在Java中使用函数类，原理是函数类型被声明为普通的接口：一个函数类型的变量是FunctionN接口的一个实现。每个接口定义了一个invoke方法，调用这个方法就会执行函数。
* lambda表达式会被正常的编译成匿名类，这表示每调用一次lambda表达式，一个额外的类就会被创建。
* 如果lambda捕捉了某个变量，那么每次调用的时候都会创建一个新的对象，这会带来运行时的额外开销，导致使用lambda比使用一个直接执行相同代码的函数效率更低。
* 如果使用inline修饰符标记一个函数，在函数被使用的时候编译器并不会函数的调用代码，而是使用函数实现的真实代码替换每一次的函数调用。
* 当一个函数被声明为inline时，它的函数体是内联的————换句话说，函数体会被直接替换到函数调用的地方，而不是被正常调用。
* 不是所有使用lambda的函数都可以被内联。当函数被内联的时候，作为参数的lambda表达式的函数体会被直接替换到最终生成的代码中。
* 即便序列上的操作都是惰性的，你不应该总是试图在集合操作的调用链后面加上asSequence。这只在处理大量数据的集合时有用，小的集合可以用普通的集合操作处理。
* 使用inline关键字只能提高带有lambda参数的函数的性能，其他的情况需要额外的度量和研究。
* 通过内联避免的运行时开销更明显，不仅节约了函数调用的开销，而且节约了为lambda创建匿名类，以及创建lambda实例对象的开销。
* 内联函数被编译后，它的字节码连同传递给它的lambda的字节码会被插入到调用函数的代码中，这使得函数调用相比于直接编写相同的代码，不会产生额外的运行时开销。
* 高阶函数促进了一个组件内的不同部分的代码重用，也可以让你构建功能强大的通用库。
* use函数是一个扩展函数，被用来操作可关闭的资源，它接收一个lambda作为参数，这个方法调用lambda并且确保资源被关闭。
* use函数是内联函数，所以使用它并不会引发任何性能开销。
* 若在lambda内使用return关键字，它会从调用的lambda的函数中返回，并不只是从lambda中返回。这样的return语句叫做非局部返回。








