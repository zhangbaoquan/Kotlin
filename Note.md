# Built application files

## 学习笔记《Kotlin实战》

### 第一、二章
* Kotlin和Java一样都是一种静态类型语言，所有表达式的类型在编译期已经确定。动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明,通常变量的类型是被赋值的那个值的类型。例如:Python、Ruby、Groovy等。
* Kotlin支持类型推导。
* Kotlin支持面向对象和面向函数两种风格。
* 数组就是类，Kotlin没有声明数组类型的特殊语法。
* if是表达式，不是语句。表达式和语句的区别是：表达式有值，并且能作为另一个表达式的一部分使用。语句总是包围着它的代码块中的顶层元素，并且没有自己的值。Java 中所有的控制结构都是语句，而Kotlin中除了循环以外，大多数控制结构都是表达式。
* val——不可变引用，初始化后不能在被赋值，对应Java的final变量。
* var——可变引用，变量的值可以被改变。
* 尽管val引用自身不可变，但是它指向的对象可能是改变的。 例如：
"""
  val languages = arrayListOf("java") // 声明不可变引用
  languages.add("Kotlin")             // 改变引用指向的对象
"""
* 只读属性只有一个getter，可写属性既有getter又有setter。
* enum 是一个软关键字，只有当它出现在class前面才有特殊的意义（即枚举的意思），其它地方可以把它当做普通的名称使用。Kotlin中的枚举类可以声明属性和方法。
* when 可以是一个有返回值的表达式。
* Java 的Switch要求必须使用常量作为分支条件。Kotlin的when允许使用任何对象。
* 如果没有给when表达式提供参数，分支条件就是任意的布尔类型表达式。
* is关键字是用来判断一个变量是否为某种类型（相当于Java的instanceof），如果检查过一个变量是某种类型，后面就不需要再转换它，可以把它当做你检查过的类型使用。Java的instanceof，即使检查是某种类型，也需要显示转换。
* 使用as可以显示特定类型的转换。
* .. 语法始终创建的是包含创结束值（..右边的值）的区间。如果想是结束区间半闭合区间，使用until函数。
* Kotlin中的throw结构是一个表达式，能作为另一个表达式的一部分使用。
* Kotlin中try关键字和if一样，引入了一个表达式，可以把它的值赋给一个变量。

### 第三章
* 可以在函数声明的时候指定参数默认值，避免创建多个重载的函数。
* 把函数放在代码文件的顶层，不用从属于任何的类。这样可以比用写静态工具类方法。
* 扩展函数可以直接访问被扩展的类的其他方法和属性，且扩展函数不能打破它的封装性，不能访问私有的或者受保护的成员。
* 实质上，扩展函数是静态函数（在Java中会被编译成静态函数），它把调用对象作为它的第一个参数。调用扩展函数，不会创建适配的对象或者任何运行的额外消耗。它的本质还是静态函数的高效语法糖。可以使用更具体的类型作为接受者类型，而不是一个类。
* 扩展函数不能被子类重写。它不是类的一部分，而是声明在类之外的。
* 扩展函数不存在重写，因为Kotlin会把他们当做静态函数对待。
* 如果父类和子类都分别定义一个同名的扩展函数，那么具体调用那个由该变量的静态类型所决定，而不是这个变量的运行时类型
* to函数是一个扩展函数，可以创建一对任何元素，它是泛型接收者的扩展。
* Kotlin中可以使用扩展函数toRegex将字符串转换为正则表达式。
* 三重引号字符串可以避免转义字符，
* 局部函数可以访问所在函数中的所有参数和变量。使用局部函数可以保证代码的整洁同时，避免重复。

### 第四章
* Kotlin的接口方法在声明时可以有默认实现。Java8 需要也可以，但需要在实现上标注default关键字。
* Kotlin中类和方法默认都是public、final的，如果想允许创建一个子类，需要使用open修饰符来标识这个类。此外，需要给每一个可以被重写的属性、方法添加open修饰符。
* 抽象类默认是open的，抽象方法在抽象类中不能有默认实现，且子类必须实现，非抽象方法默认是final的，声明后必须有默认实现。
* Kotlin没有default关键字（该关键字在Java中对应的是包可见性），但是提供了internal——只在模块内部可见，一个模块就是一组一起编译的Kotlin文件。
* internal是Kotlin独有的，在编译成字节码时对应的是Java的public，由于可见性范围和Java区别，因此最好不要使用internal，否则会导致Java和Kotlin互相调用异常。
* Kotlin中protected成员只能在类和它的子类中可见，类的扩展函数不能访问它的private和protected成员。
* Kotlin的嵌套类不能访问外部类的实例。
* 类A（作为嵌套类）在类B中声明，如果类A不想存储外部类B的引用，在Java中声明类A的方式是static class A，在Kotlin中声明类A的方式是class A。即Kotlin中没有显示修饰符的嵌套类与Java中的static嵌套类是一样的。
* 类A（作为嵌套类）在类B中声明，如果类A存储外部类B的引用，在Java中声明类A的方式是class A，在Kotlin中声明类A的方式是inner class A。
* When结构来执行表达式的时候，Kotlin编译器会强制检查默认选项。
* 在When表达式中处理所有的sealed类的子类，就不需要再提供默认分支。sealed修饰符隐含的这个类是一个open。
* sealed修饰的类叫做密闭类，相当于Java的枚举类Enum。
* init关键字用来引入一个初始化语句块，在类被创建时执行的代码块。
* 如果所有的构造方法参数都有默认值，编译器会生成一个额外的不带参数的构造方法来使用所有的默认值。
* 不要声明多个从构造方法用来重载和提供参数的默认值，取而代之的是应该直接标明默认值。
* Kotlin中的== 相当于Java的equals（比较的是对象的值），Kotlin中的 === 相当于Java的==（比较的是对象的引用）
* object关键字定义一个类并同时创建一个实例（对象），对象的声明是定义一个单例的一种方式。
* object声明类不能有构造方法（包括主构造、从构造）
* Kotlin中的对象声明被编译成了通过静态字段来持有它的单一实例的类，这个字段名称始终是INSTANCE，因此，要从Java代码中使用Kotlin对象，可以通过访问静态的INSTANCE字段。
* Kotlin中的类不能拥有静态成员；Java的static关键字不是Kotlin语言的一部分。Kotlin依赖的是包级别函数和对象声明。
* 在没有类实例的情况下调用但是需要访问类内部的函数，可以将其写成那个类的对象声明的成员。
* 伴生对象可以访问类中所有的private成员，包括private 构造方法。
* 使用companion object （伴生对象）可以直接通过容器类名来访问这个对象的方法和属性，写法上非常像Java的静态方法调用。也可以实现单例（相当于Java的静态内部类的写法）
* Kotlin可以访问在Java类中声明的静态方法和字段，使用与Java相同的语法。
* object 关键字还可以声明匿名对象。匿名对象替代了Java中匿名内部类的写法。

### 第五章
* Lambda 的本质是可以传递给其它函数一小段代码.
* 当lambda是函数唯一的实参时，可以去掉调用者代码中空括号对。如果实参可以导出来，也可不用显示指定。
* 在嵌套lambda中，最好显示的声明每个lambda的实参.
* Kotlin允许在lambda内部访问非final变量甚至修改它，Java不行。
* filter 函数可以从集合中过滤掉一些元素，但不会真正的改变这个集合
* map函数可以对集合中的每一个元素应用给定的函数并把结果收集到一个新的集合中。
* filter 和 map都会返回一个列表。
* Kotlin 的Sequence接口表示一个可以逐个列举元素的元素序列，内部提供了一个方法，iterator，用来从序列中获取值。
* 序列中的元素求值是惰性的，因此可使用序列更加高效的对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的中间结果。
* 在序列操作中，map、filter都是中间操作，返回是另一个序列，toSet是一次末端操作，返回的是一个结果。没有末端操作的调用，中间操作是不会被调用的。
* 即序列是允许你合并一个集合上的多次操作，而不需要创建新的集合来
* lambda内部没有匿名对象那样的this，没有办法引用到lambda转换成匿名类实例。
* lambda中的this引用指向的是包围它的类
* with的返回值是执行lambda的结果，该结果是lambda中最后一个表达式
















