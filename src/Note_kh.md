# Built application files

## 学习笔记《Kotlin核心编程》，深入理解Kotlin原理

### 第一章
* 描述Kotlin的一些特性，对比其它语言（这里主要对比Java），它的语法更加简洁，对Java的兼容做的很好。
* 提供了大量的语法糖，使代码更加的安全

### 二章 基础语法(变量类型、高阶函数)
* 尽可能的采用val、不可变对象及纯函数来设计程序。
* 使用val来声明一个本身不可变的变量会更加安全，因为它永远不会在其他地方修改，且更加容易理解。
* val声明的变量是只读变量，它的引用不可变，但引用的对象可以改变。

* 高阶函数：把其它函数作为参数或者返回值的函数。

* Lambda表达式本质就是一个语法糖。

* Kotlin在JVM层设计了Function类型（从0到22）【其实就是一个接口】，来兼容Java的Lambda表达式。
* 在调用lambda表达式时，实质上只是构造了Function对象。
* 至于为什么是22，这个是行业里一个惯例，Scala也遵循了22，如果超过22，Kotlin提供了一个FunctionN。

* Kotlin的闭包不仅可以访问外部变量，还可以修改

* if、when 、try 等都是用来表达式，表达式有返回值，其中when可以取代Java的三目运算

* 结构相等，== 来判断两个对象的内容，相当于Java的equal
* 引用相等，=== 来判断对象的引用，相当于Java的==

### 三章 面向对象（接口、init、延迟初始化，作用域，接口实现多继承，内部类）
* 接口方法支持默认实现（Java 是从Java 8开始支持），
* 为了能兼容Java的低版本（Kotlin是基于Java6），Kotlin编译器通过定义一个静态内部类来提供默认方法的实现。
* Kotlin接口支持默认抽象属性（其背后的原理是用方法实现的）。

* 支持构造方法参数指定默认值，解决Java方法重载过多导致的方法冗余问题。

* init 语句块是构造方法的一部分，可以调用构造方法里的参数。
* 构造方法可以有多个init，执行顺序自上而下。

* Kotlin 支持两种延迟初始化：by lazy 和 lateinit.

* by lazy : 声明的变量必须是val。在首次被调用时才会进行赋值，一旦赋值就不能更改。
* by lazy 原理：接受一个Lambda并返回一个lazy<T>实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问该属性时只返回记录的结果。
* 系统会给lazy 属性默认加上一个同步锁，也就是lazyThreadSafetyMode.SYNCHRONIZED，它在同一时刻只允许一个线程对lazy属性进行初始化。所以它是线程安全的。

* lateinit 主要是用于var声明的变量，然而它不能用于基本数据类型，如long、Int等，需要使用Integer这种包装类作为替代。

* 如果一个类存在主构造方法，那么每个从构造方法都要直接或间接的委托给它。

* kotlin中的类和方法默认是不可以被继承或者重写，默认final会更加安全。

* 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。

* sealed 关键字修饰一个类为密闭类，若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承这个类。
* 密闭类的局限性是不能被初始化，因为它背后是基于一个抽象类实现的。

* Java 的protected 修饰内容的作用域是包内、类以及子类。Kotlin没有包作用域的概念，因此作用域仅在类以及子类。
* Kotlin的internal关键字修饰的作用域是"模块内访问"。

* 接口可以实现多继承，若调用两个相同名的方法时，可以利用super关键字来指定继承那个父类接口的方法。

* 用val声明的属性将只有getter 方法，因为它不可以被修改。若使用var修饰，可以同时拥有getter方法和setter方法。

* Kotlin中声明内部类，必须在class关键词前加上inner 关键字，包含外部类的实例引用，可以调用外部类的属性。如果直接写就是嵌套类（或者说是静态内部类）

* 伴生对象是Kotlin用来代替static关键字的一种方式，任何在Java内部使用static定义的内容都可以用Kotlin的伴生对象实现。一个类的半生对象和跟一个静态类一样，全局只能有一个。

* 使用object 实现单例，单例对象会在系统加载时候初始化，全局只有一个。

### 四章 代数数据类型 和 模式匹配
* 。

### 五章 类型系统（空安全 & 泛型）的原理分析
* 。

### 六章 Lambda 和 集合
* 。