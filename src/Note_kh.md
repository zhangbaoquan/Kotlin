# Built application files

## 学习笔记《Kotlin核心编程》，深入理解Kotlin原理

### 第一章
* 描述Kotlin的一些特性，对比其它语言（这里主要对比Java），它的语法更加简洁，对Java的兼容做的很好。
* 提供了大量的语法糖，使代码更加的安全

### 二章 基础语法(变量类型、高阶函数)
* 尽可能的采用val、不可变对象及纯函数来设计程序。
* 使用val来声明一个本身不可变的变量会更加安全，因为它永远不会在其他地方修改，且更加容易理解。
* val声明的变量是只读变量，它的引用不可变，但引用的对象可以改变。

* 高阶函数：把其它函数作为参数或者返回值的函数。

* Lambda表达式本质就是一个语法糖。

* Kotlin在JVM层设计了Function类型（从0到22）【其实就是一个接口】，来兼容Java的Lambda表达式。
* 在调用lambda表达式时，实质上只是构造了Function对象。
* 至于为什么是22，这个是行业里一个惯例，Scala也遵循了22，如果超过22，Kotlin提供了一个FunctionN。

* Kotlin的闭包不仅可以访问外部变量，还可以修改

* if、when 、try 等都是用来表达式，表达式有返回值，其中when可以取代Java的三目运算

* 结构相等，== 来判断两个对象的内容，相当于Java的equal
* 引用相等，=== 来判断对象的引用，相当于Java的==

### 三章 面向对象（接口、init、延迟初始化，作用域，接口实现多继承，内部类）
* 接口方法支持默认实现（Java 是从Java 8开始支持），
* 为了能兼容Java的低版本（Kotlin是基于Java6），Kotlin编译器通过定义一个静态内部类来提供默认方法的实现。
* Kotlin接口支持默认抽象属性（其背后的原理是用方法实现的）。

* 支持构造方法参数指定默认值，解决Java方法重载过多导致的方法冗余问题。

* init 语句块是构造方法的一部分，可以调用构造方法里的参数。
* 构造方法可以有多个init，执行顺序自上而下。

* Kotlin 支持两种延迟初始化：by lazy 和 lateinit.

* by lazy : 声明的变量必须是val。在首次被调用时才会进行赋值，一旦赋值就不能更改。
* by lazy 原理：接受一个Lambda并返回一个lazy<T>实例的函数，第一次访问该属性时，会执行lazy对应的Lambda表达式并记录结果，后续访问该属性时只返回记录的结果。
* 系统会给lazy 属性默认加上一个同步锁，也就是lazyThreadSafetyMode.SYNCHRONIZED，它在同一时刻只允许一个线程对lazy属性进行初始化。所以它是线程安全的。

* lateinit 主要是用于var声明的变量，然而它不能用于基本数据类型，如long、Int等，需要使用Integer这种包装类作为替代。

* 如果一个类存在主构造方法，那么每个从构造方法都要直接或间接的委托给它。

* kotlin中的类和方法默认是不可以被继承或者重写，默认final会更加安全。

* 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。

* sealed 关键字修饰一个类为密闭类，若要继承则需要将子类定义在同一个文件中，其他文件中的类将无法继承这个类。
* 密闭类的局限性是不能被初始化，因为它背后是基于一个抽象类实现的。

* Java 的protected 修饰内容的作用域是包内、类以及子类。Kotlin没有包作用域的概念，因此作用域仅在类以及子类。
* Kotlin的internal关键字修饰的作用域是"模块内访问"。

* 接口可以实现多继承，若调用两个相同名的方法时，可以利用super关键字来指定继承那个父类接口的方法。

* 用val声明的属性将只有getter 方法，因为它不可以被修改。若使用var修饰，可以同时拥有getter方法和setter方法。

* Kotlin中声明内部类，必须在class关键词前加上inner 关键字，包含外部类的实例引用，可以调用外部类的属性。如果直接写就是嵌套类（或者说是静态内部类）

* 伴生对象是Kotlin用来代替static关键字的一种方式，任何在Java内部使用static定义的内容都可以用Kotlin的伴生对象实现。一个类的半生对象和跟一个静态类一样，全局只能有一个。

* 使用object 实现单例，单例对象会在系统加载时候初始化，全局只有一个。

### 四章 代数数据类型 和 模式匹配
* when 的各种高级玩法。

### 五章 类型系统（空安全 & 泛型）的原理分析
* Java解决NPE的办法：
  1、try catch
  2、采用@Nullable / @NotNull注解来标注
  3、使用专门的Optional对象对可能为null的变量进行装箱

* Java的Optional存在问题： Optional的耗时大约是普通判空的数十倍。
  主要因为Optional<T>是一个包含测试类型T引用的泛型类，在使用的时候多创建了一次对象，当数据量很大时频繁实例化对象会造成性能损失（开源项目中也很少使用）

* Kotlin的可空类型实质上只是在Java的基础上进行了语法层面的包装（智能类型转换也是如此）。性能以及兼容性上要比Optional好。

* Any 类型是Kotlin中所有非空类型的超类，类似Java中的Object。当在Kotlin中使用Any时，它会被编译成Java字节码中的Object。

* Kotlin中的Int在JVM中实际以int存储。kotlin中的Int类型等同于Java里的int，kotlin中Int?等同于Integer。

* Java 无法声明一个泛型数组，原因是Java数组是协变的，而List是不变的。
* Java 中的泛型是类型擦除的，可以看作伪泛型，即无法在程序运行时获取到一个对象的具体类型。数组在运行时是可以获取自身的类型。
* Kotlin中的数组支持泛型，因此也不再协变。
* Kotlin的泛型机制和Java一样，也是类型擦除实现的。

* 类型检查是编译器在编译前就会帮我们进行类型检查，所以类型泛型擦除不会影响它。

* 泛型的类型擦除并不是真的将全部的类型信息都擦除，还是会将类型信息放在对应class的常量池中的。
* 匿名内部类在初始化的时候就会绑定父类或父接口的相应信息，这样就能通过获取父类或者父接口的泛型类型信息。
* 也可以使用内联函数获取泛型信息，由于在编译时会将具体的类型插入相应的字节码中，因此就可以在运行时获取到对应参数的类型。
* Kotlin中声明的普通内联函数可以在Java中调用，只是被当做普通函数而已。

* 如果在定义的泛型和泛型方法的泛型参数前面加上out关键词，说明这个泛型类及泛型方法是协变。简单来说是类型A是类型B的子类型，那么Generic<A>也是Generic<B>的子类型。
* 支持协变的List只可以读取，不能添加。
* 用out关键字声明的泛型参数类型将不能作为方法的参数类型。
* in 和 out 是一个对立面，其中in代表泛型参数类型逆变，out代表泛型参数类型协变。

* Java中的泛型类型通配符是 ？，Kotlin中则用 * 来表示类型通配符。

### 六章 Lambda 和 集合
* 。